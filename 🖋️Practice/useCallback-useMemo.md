# useCallback & useMemo

<br>
<br>

> 연습내용

<br>

```
useCallback 및 useMemo는 특히 불필요한 재렌더링 및 계산을 줄이는 
특정 시나리오에서 성능을 최적화하기 위한 React Hooks

-------------------------------------------------------------

@ useCallback
    종속성 중 하나가 변경된 경우에만 
    변경되는 콜백 함수의 메모화된 버전을 반환
    
    불필요한 렌더링을 방지하기 위해 
    참조 동등성에 의존하는 최적화된 
    자식 컴포넌트에 콜백을 전달할 때 유용


    - EX 
        'React.memo' 또는 'PureComponent' 자식 컴포넌트에 
        메모되지 않은 콜백을 전달하면 매번 콜백이 다시 생성되기 때문에 
        자식 컴포넌트는 부모가 렌더링될 때마다 리렌더링
        
        useCallback은 종속 항목이 변경되지 않는 한 
        콜백이 동일한 ID를 유지하도록 하여 이를 방지

-------------------------------------------------------------

@ useMemo
    메모된 값을 반환, 렌더링 중에 
    비용이 많이 드는 계산이 실행될 때 유용
    성능을 보다 효율적으로 구현 가능
    (예: 큰 배열 또는 개체 처리, 복잡한 계산 수행 등) 

    아이디어는 useMemo의 종속성이 렌더링 간에 
    변경되지 않은 경우 React가 계산 재실행을 건너뛰고 
    이전 결과를 재사용 가능 
    
-------------------------------------------------------------

@ 주의 사항
    => useCallback 및 useMemo에도 비용 존재

    콜백 또는 값을 저장하기 위한 
    메모리 오버헤드와 종속성 비교를 
    실행하기 위한 CPU 오버헤드가 포함

    따라서 재렌더링이나 계산을 피하는 이점이 
    이러한 오버헤드보다 클 때 신중하게 사용

    => 즉, 기본적으로 모든 곳에서 사용 불가능

    성능이 중요한 부분이나 눈에 띄는 
    성능 문제가 불필요한 재렌더링 
    또는 렌더링 중 과도한 계산으로 
    역추적될 수 있는 경우에 가장 잘 사용

-------------------------------------------------------------

# 빈 종속성으로 사용한 경우
    => 쓸모가 없지만 동작이 예상과 다를 수 있음

    useCallback의 경우 빈 종속성 배열을 제공하면 
    메모된 콜백이 다시 생성되지 않으며 항상 동일한 ID를 소유 
    
    이것은 콜백이 외부 변수에 의존하지 않는 경우 
    유용할 수 있지만 대부분의 경우 콜백은 아마도 
    소품이나 상태에 의존하고 이러한 변경으로 인해 
    버그가 발생할 수 있는 경우 업데이트 X

    ---

    useMemo의 경우 빈 종속성 배열은 
    메모된 값이 한 번만 계산되고 
    다시 계산되지 않음을 의미
    
    다시 말하지만 값을 계산하는 데 
    비용이 많이 들고 props 나 state에 
    의존하지 않는 경우 유용 가능 
    
    그러나 그것이 props나 state에 의존한다면,
    memorized 값은 초기 렌더링 후에 오래되고 부정확

    요컨대 빈 종속성 배열은 본질적으로 쓸모가 없지만 
    콜백이나 값이 진정으로 어떤 props 나 state에 
    의존하지 않는 경우에만 사용
    
    후크가 props에 의존하는지 state에 의존하는지 
    확실하지 않은 경우 종속성 배열에 포함하는 것이 더 안전

-------------------------------------------------------------

- tip

    React Profiler를 사용하여 컴포넌트를 프로파일링하는 것
    이를 통해 구성 요소가 렌더링되는 빈도와 각 렌더링에 걸리는 
    시간에 대한 실제 데이터를 얻을 수 있음
    
    프로파일러가 계산이 성능 병목 현상임을 
    표시하면 메모이제이션이 좋은 생각
```
