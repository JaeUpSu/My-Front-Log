@ HTTPS 와 HTTP 차이

   - SSL 과 TLS 를 사용하여 HTTP 요청 및 응답을 암호화
      데이터 보안 유지, 무결성 유지

<br>

@ HTTPS 어떻게 호스팅

  - CA 기관에 SSL/TLS 인증서를 받아 
      서버에 파일 추가 및 구성

<br>

@ Virtual DOM 설명

   - 실제 DOM 의 직접 조작을 최소화하기 위해
       Virtual DOM 을 통한 상태 변화 유무로
     실제 DOM 을 업데이트하는 방식

	-> 최적화와 성능 up 
	    (최소 변경집합 계산하여 UI 필요부분만 조정)

<br>

@ React 상태의 불변성

   - 불변성은 명확하고 추적 가능한 데이터 흐름을 허용
      응용 프로그램을 더 쉽게 추론하고 디버깅할 수 있도록 함

<br>

@ Virtual DOM 과 React 상태관리 불변성과 연관지어 설명

   - 실제 DOM 의 직접 조작 X
     가상 DOM 으로 변화 감지 용이, 
     최적화된 렌더링, 시간여행 디버깅 및 롤백 용이

<br>

@ API 설명

   - 한 프로그램에서 다른 프로그램으로 데이터를 주고 받는 방법

<br>

@ RESTFul 정의와 논리

   - 표현된 상태로 전송
      HTTP Method (GET/POST/PUT/DELETE) 로
    해당 자원에 대한 CRUD Operations 을 적용

	-> 자원 : HTTP URI
	-> 자원에 대한 행위 : HTTP Method
	-> 자원에 대한 행위의 내용 : HTTP Message Pay Load 

     - 특징
    	Server-Client(서버-클라이언트 구조) => 독립적
    	Stateless(무상태) => 상태를 갖지 않음, 확장성 or 간단함
    	Cacheable(캐시 처리 가능) => 클라이언트 응답 캐싱 and 재사용 가능
    	Layered System(계층화) => APP 은 클라이언트와 서버 사이 동일 작동
    	Uniform Interface(인터페이스 일관성)
    	 => URI 로 리소스에 대한 조직 통일, 예측 가능하게 상호작용 
                     HTTP 메서드 이용

<br>

@ RESTFul 과 CRUD 맵핑

   - Create | POST/PUT
   - Read   | GET
   - Update | PUT/PATCH
   - Delete | DELETE

<br>

@ RESTFul 장점

  - 확장성 / 유연성 / 독립성

<br>

@ PUT / PATCH 다른 점

  - PATCH 는 리소스 일부
  - PUT 은 전체 리소스를 교체 업데이트

<br>

@ Local Storage / Session Storage / Cookie 다른 점

  - 데이터 유지 기간과 용량
      각기 다른 보안

 	    -> Local Storage   
	    	(영구적 / 용량 Big / JS 접근 가능하여 XSS 공격 취약)
 	    -> Session Storage 
	    	(창을 닫을때 / 용량 Medium / JS 접근 가능하여 XSS 공격 취약)
 	    -> Cookie	   
	    	(유효기간 존재 / 용량 Small / 중간자 공격 취약)


	    => Storage, XSS 공격은 HTTP Only 로 방지 (스크립트 접근 막음)
	    => Cookie, 중간자 공격은 HTTPS 로 방지
	    =>         CSRF 공격은 Samsite 속성으로 방지
  
<br>


@ 인증과 인가 설명

  - 인증 : 어떤 사실을 진짜인지 증명
  - 인가 : 접근 권한 부여, 가능한지 확인
  
<br>


@ JWT Flow 는?

  - 로그인 => 인증 => JWT 생성 => 발행 => 저장 
	=> 인증요청 => JWT 검증 => 인증된 요청 처리

       - Header . Payload . Signature

    	=> 헤더 (토큰, 사용 서명 알고리즘)
    	=> 내용 (클레임, 사용자 권한 정보와 데이터)
    	=> 서명 (인코딩한 문자열, 비밀키)

      - 리프레시 토큰으로 액세스 토큰을 재발급
        리프레시 토큰이 만료되면 다시 로그인 요청

      - JWT 검증할 때, 서버는 exp 클레임을 확인하여 토큰 만료 판단

      - 토큰 탈취는 중간자 공격 / XSS 공격 / 피싱

  
<br>


@ Next.js 와 CRA 

   - SSR 과 SSG 가 있는 Next.js 는 복잡한 app 적합
   - SPA 가 있는 CRA 는 상대적으로 간단한 app 적합

  
<br>


@ Git 에서 PR 할 때 rebase 와 merge 의 차이 설명

   - merge : 각 브랜치의 끝 부분을 병합
   - rebase: 한 브랜치의 변경사항을 다른 브랜치 위로 적용

  
<br>


@ Promises 설명

   - 비동기 작업의 최종 완료 또는 실패를 나타내는 객체

  
<br>


@ async-await 설명

   - 비동기 처리를 동기 처럼 보이게 함
        Promises 를 더 간결하고 이해하기 쉽게 처리

  
<br>


@ Cookie 와 Header 를 연관지어 설명

   - 세션 관리나 사용자 인증 등의 기능을 구현하는데 있어 중요

  
<br>


@ CorsHeader 설명

   - 다른 도메인에서 리소스를 공유하도록 해주는 웹 표준

  
<br>


@ CorsHeader 에러 확인

   - 웹 브라우저 콘솔에서 확인가능
  
<br>



@ Proxy 에 대해 원리와 정의 설명

   - 네트워크에서 한 컴퓨터가 다른 컴퓨터의 연결을 대신하는 것
  
<br>


---
  
<br>


@ CRA 의 CSR 정의

   - 서버는 처음에 최소한의 HTML 파일과 JavaScript 번들을 클라이언트에 전송 
     번들의 JavaScript 코드는 클라이언트의 브라우저에서 실행되어 콘텐츠를 렌더링하고 
       페이지를 대화식으로 생성, 클라이언트 측 JavaScript 코드는 추가 서버 요청 없이 
       후속 렌더링 및 업데이트를 처리
  
<br>


@ Next.js 의 SSR 정의

   - 서버에서 HTML 콘텐츠를 생성 및 렌더링하고 완전한 HTML을 클라이언트한테 전송

  
<br>


@ HTTP 메서드에서 GET 과 POST 는 보안의 차이

   - HTTPS 를 전제로 했을 때 POST 요청은 URL 을 노출하지 않고 브라우저 기록 또한
     않고 전송하기 때문에 민감한 정보를 전송할 때 더 안전하다고 간주
  
<br>


@ 홈페이지가 사용자에게 보이는 순서

   - 1. 주소창에 입력된 주소를 통해 브라우저 URL을 해석해 서버를 찾아감
     2. 이후 DNS가 연결해 줄 곳을 탐색 (실제서버)
     3. 서버에서 클라이언트가 요청한 자원을 전송 (보통 HTML 문서)
     4. 클라이언트는 HTML문서를 파싱하여 DOM을 생성
     	4-1. 중간에 CSS나 JS 스크립트를 다운받는 태그를 만나면 
	     DOM 생성을 중지하고 해당 자원들을 다운로드
     5. HTML -> DOM, CSS -> CSSOM 을 생성
     6. 만들어진 DOM과 CSSOM을 브라우저에 렌더링 하기 위해 렌더 트리로 결합
     7. 만약 script 태그를 만나면, css와 동일하게 JS코드를 실행하기 위해 
          파싱을 중단하고, 이후 JS엔진을 실행하고 JS코드를 파싱
  
<br>


@ 브라우저의 주요 기능

   - 사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는것
  
<br>


@ 브라우저 엔진이란?

   - 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어
  
<br>


@ 렌더링 엔진이란?

   - 요청한 컨텐츠를 브라우저 화면에 표시
	(Gecko 엔진, WebKit 엔진)
  
<br>


@ 렌더링 엔진 동작 과정?

   - DOM 트리 구축을 위한 HTML 파싱
   - 렌더 트리 구축
   - 렌더 트리 배치
   - 렌더 트리 그리기
  
<br>


@ 호이스팅이란?

     - 변수 및 함수 선언이 코드 내의 실제 위치에 관계없이 
        컴파일 단계에서 해당 범위의 맨 위로 이동되는 JavaScript 동작


<br>


@ 클로저란?

      - 내부 함수가 외부 함수의 변수를 참조하여 "닫힌" 범위를 형성할 때 생성
      - 데이터 프라이버시 및 캡슐화 구현.
         지속 상태로 함수 생성.
         비동기 작업 관리.

	=> 상태를 관리하고 조작하기 위한 필수 메커니즘을 제공

  
<br>


@ Cors Header 란?

    - 웹 브라우저에서 서로 다른 출처(도메인) 간에 공유되는
      리소스에 대한 액세스를 제어하는 메커니즘

    - 승인되지 않는 출처간 요청을 방지하기위해 브라우저에서 
      구현한 보안기능


    - Back 

	CORS 헤더 설정
	  - 서버는 허용되는 교차 출처 요청에 대해 브라우저에 
	    알리기 위해 응답에 적절한 CORS 헤더를 포함해야 함 
	    헤더에는 일반적으로 Access-Control-Allow-Origin, 
	    Access-Control-Allow-Methods, 
	    Access-Control-Allow-Headers 등이 포함
  
<br>



@ DRF 란?

      - 웹 API를 구축하기 위한 강력하고 유연한 툴킷

      - RESTful API의 개발을 단순화하는 재사용 가능한 
        구성 요소 및 도구 세트를 제공하여 직렬화, 인증, 권한 
        등과 같은 일반적인 API 작업을 더 쉽게 처리
     
      - 기능이자 장점
	        직렬화
	        보기 및 보기 세트
	        인증 및 권한
	        URL 라우팅
	        페이지 매김 및 필터링

  
<br>


@ NEXT.js 13 패치 내용

      - app 디렉터리
	     pages 사라질 예정
	        *  React Server Components 와 새롭게 생기는 
	           Data fetching 기능, 그리고 Streaming등을 
	           유연하게 지원하게 하기 위함

      - next/image

      - next/font

      - next/link

  
<br>


@ CI / CD 란?

    - CI : 지속적인 통합
    - CD : 지속적인 배포

    - SW 변경 사항을 지속 가능하고 효율적인 방식으로 
       프로덕션에 자동으로 구축, 테스트 및 배포하는 방법


	-  GitHub Actions를 사용하여 기본 CI/CD 
	   파이프라인을 설정, 워크플로 만들기


	-  GitHub Actions는 push 또는 pr 과 같은  
	   GitHub 리포지토리의 특정 이벤트에 의해 
	   트리거되는 워크플로를 정의하여 작동

  
<br>


  
<br>


@ 일반적인 너비

    - 320
    - 480
    - 760
    - 960
    - 1200
    - 1600




@ csr / ssr / ssg 각각 적합한 사용 ?

	- 클라이언트측 렌더링(CSR):
		대화형 또는 동적 페이지
  			클라이언트 측 상호작용에 크게 의존하거나 초기 페이지 로드 후 
     			빈번한 데이터 업데이트가 필요한 페이지는 CSR에 적합
	
 			예를 들면 채팅 응용 프로그램, 실시간 공동 작업 도구 또는 대화형 양식이 있습니다.

	- 서버측 렌더링(SSR)
		개인화 또는 동적 콘텐츠가 있는 페이지
  			SSR은 사용자별 데이터를 기반으로 개인화가 필요하거나 
     			서버에서 렌더링해야 하는 동적 콘텐츠가 있는 페이지에 적합
	
 			예를 들면 사용자 프로필, 계정 대시보드 또는 콘텐츠가 자주 변경되는 페이지가 있습니다.

	- 정적 사이트 생성(SSG)
		콘텐츠 기반 페이지
  			SSG는 실시간 업데이트가 필요하지 않고 빌드 프로세스 중에 
     			미리 렌더링할 수 있는 콘텐츠 기반 페이지에 이상적
	
 			예를 들면 블로그 게시물, 제품 목록, 마케팅 랜딩 페이지 
    			또는 설명서 페이지가 있습니다.
       			
	  		SSG는 콘텐츠가 미리 생성되므로 빠른 로딩 시간과 향상된 SEO를 제공합니다.



